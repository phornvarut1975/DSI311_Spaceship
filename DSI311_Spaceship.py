# -*- coding: utf-8 -*-
"""คห.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cVC4M6-lbZ489k69dG7KjuS_TgDlhKCE
"""

# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import matplotlib.pyplot as plt
import seaborn as sns
from catboost import Pool, CatBoostClassifier

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All" 
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session

"""# Load Data

หลังจากนำเข้า library ที่ต้องใช้เรียบร้อยแล้ว ขั้นตอนถัดมาคือทำการนำเข้า Data Frame และเปลี่ยนฟีเจอร์ PassengerID ให้กลายเป็น index คือ หมายเลข รายการ หรือชื่อคอลัมน์ เพื่อใช้เป็นดัชนี (ป้ายกำกับแถว) ของ DataFrame ที่เป็นผลลัพธ์ โดยค่าเริ่มต้น จะกำหนดหมายเลขแถวโดยไม่ต้องใช้คอลัมน์ใดๆ เว้นแต่จะมีคอลัมน์ข้อมูลมากกว่าหนึ่งคอลัมน์ที่มีส่วนหัว
"""

train_df = pd.read_csv('/kaggle/input/spaceship-titanic/train.csv', index_col='PassengerId')
test_df = pd.read_csv('/kaggle/input/spaceship-titanic/test.csv', index_col='PassengerId')

"""# Data Exploration

หลังจากที่ได้นำเข้าข้อมูล เราจะนำข้อมูลมาวิเคราะห์เบื้องต้นว่ามีแนวโน้มเป็นอย่างไร โดยการแสดงผลด้วยกราฟหรือตาราง เพื่อทำให้เราสามารถวิเคราะห์ข้อมูลได้ถูกต้องและแม่นยำมากขึ้น

ตรวจสอบขนาดของ Data Frame เพื่อต้องการดู dimension ของ Data Frame ว่ามีจำนวน columns และ rows เท่าไหร่บ้าง ทั้ง Train, Test ซึ่งสามารถเรียกดู attribute.shape ของ object นั้นๆ
"""

print("train size:", train_df.shape)
print("test size:", test_df.shape)

"""หลังจากโหลดข้อมูลเข้ามาแล้วเราจะเรียกดู info ของข้อมูลใน Data Frame ว่ามีกี่แถว และ ดูภาพรวมของฟีเจอร์ต่างๆ จะเห็นได้ว่าเกือบทุกคอลัมน์มีข้อมูลไม่ครบถ้วนหรือ Missing Values อยู่ และแต่ละคอลัมน์เป็น Data Type อะไร"""

train_df.info()

test_df.info()

"""ต่อมาใช้ describe() เพื่อเรียกดู Distribution หรือ ข้อมูลทางสถิติต่างๆในแต่ละคอลัมน์ของ Data Frame ได้"""

train_df.describe()

"""ทำการสุ่มดูข้อมูล 10 แถวของ Data Frame เพื่อดูตัวอย่างข้อมูลของ train ว่ามีข้อมูลในแต่ละฟีเจอร์เป็นอย่างไรบ้าง"""

train_df.sample(10)

"""ปรับขนาดของภาพได้ด้วยการเติมคีย์เวิร์ดในฟังก์ชัน plt.figure
figsize คือขนาดของรูปในแนวตั้งและแนวนอน โดยต้องใส่ในรูปทูเพิลหรือลิสต์

ต่อมาทำการตรวจสอบจำนวนของผู้โดยสารที่ถูกย้ายไปยังมิติอื่น เพื่อให้แน่ใจว่าชุดข้อมูลสำหรับtrainนี้จะไม่มีปัญหาเรื่อง Imbalance Class
ซึ่งจะเห็นได้ว่าจำนวนข้อมูลของผู้ที่ย้ายไปมิติอื่นกับผู้ที่ไม่ถูกย้ายมีจำนวนไม่แตกต่างกันมาก
"""

plt.figure(figsize=(18,6))
train_df['Transported'].value_counts().plot(kind='bar', title='Transported')

"""สำรวจอายุของผู้โดยสาร พบว่าอายุของผู้โดยสารส่วนใหญ่อยู่ในช่วง วัยผู้ใหญ่ หรือ วัยทำงาน"""

plt.figure(figsize=(20,6))
train_df['Age'].value_counts().plot(kind='bar', title='Age')

"""ต่อไปคือการสำรวจฟีเจอร์ต่างๆ เทียบกับฟีเจอร์ Transported เพื่อดูความสัมพันธ์ของข้อมูล

พบว่าข้อมูลในฟีเจอร์ HomePlanet ส่วนใหญ่แล้วผู้โดยสารจะมาจาก Earth Europa และ Mars รองลงมาตามลำดับ
"""

plt.figure(figsize=(18,6))
train_df['HomePlanet'].value_counts().plot(kind='bar', title='HomePlanet')

"""ผู้โดยสารที่มาจาก Europa ส่วนใหญ่จะถูกย้ายไปยังมิติอื่นเป็นสองเท่าของคนที่ไม่ถูกย้าย ส่วนผู้โดยสารที่มาจาก Earth ส่วนใหญ่จะไม่ถูกย้ายไปยังมิติอื่น และผู้โดยสารที่มาจาก Mars นั้นมีจำนวนของผู้ที่ถูกย้ายและไม่ถูกย้ายไม่ต่างกันมากนัก"""

for val in list(train_df['HomePlanet'].unique()):
    print(f"{val} Transported")
    print(train_df.loc[train_df['HomePlanet'] == val]['Transported'].value_counts(), "\n")

"""จากข้อมูลฟีเจอร์ Destination นั้นพบว่า
- ผู้โดยสารส่วนใหญ่จะเดินทางไป TRAPPIST-1e และมีเดินไปทางไป 55 Cancri e กับ PSO J318.5-22 เป็นส่วนน้อย 
- ผู้โดยสารที่เดินทางไป TRAPPIST-1e ส่วนใหญ่จะไม่ถูกย้ายไปยังมิติอื่น 
- ผู้โดยสารที่เดินทางไป 55 Cancri e ส่วนใหญ่จะถูกย้ายไปยังมิติอื่น 
- ผู้โดยสารที่เดินทางไป PSO J318.5-22 นั้นมีจำนวนผู้ที่ถูกย้ายและไม่ถูกย้ายพอ ๆ กัน
"""

plt.figure(figsize=(18,6))
train_df['Destination'].value_counts().plot(kind='bar', title='Destination')

for val in list(train_df['Destination'].unique()):
    print(f"{val} Transported")
    print(train_df.loc[train_df['Destination'] == val]['Transported'].value_counts(), "\n")

"""จากข้อมูลฟีเจอร์ CryoSleep พบว่าส่วนใหญ่
- ผู้โดยสารไม่นอนใน CryoSleep ค่านี้ค่อนข้างสอดคล้องกับการถูกย้ายไปมิติอื่นพอสมควร โดยจะเห็นได้ว่าผู้โดยสารที่ไม่นอนใน CryoSleep นั้นส่วนใหญ่จะไม่ถูกย้ายไปยังมิติอื่น 
- แต่ในทางกลับกันผู้โดยสารที่นอนใน CryoSleep นั้นส่วนใหญ่จะถูกย้ายไปยังมิติอื่น
"""

plt.figure(figsize=(18,6))
train_df['CryoSleep'].value_counts().plot(kind='bar', title='CryoSleep')

for val in list(train_df['CryoSleep'].unique()):
    print(f"{val} Transported")
    print(train_df.loc[train_df['CryoSleep'] == val]['Transported'].value_counts(), "\n")

"""จากข้อมูลฟีเจอร์ VIP พบว่าผู้โดยสารส่วนใหญ่ไม่ได้จ่ายเงินเพื่อเป็น VIP"""

plt.figure(figsize=(18,6))
train_df['VIP'].value_counts().plot(kind='bar', title='VIP')

for val in list(train_df['VIP'].unique()):
    print(f"{val} Transported")
    print(train_df.loc[train_df['VIP'] == val]['Transported'].value_counts(), "\n")

"""เราต้องการทราบค่าต่างๆ แต่ถ้าออกมาในรูปแบบตัวเลขจะดูยากทำให้เราใช้ seaborn แสดงผลเป็น heatmap แสดงความสัมพันธ์ของข้อมูลแต่ละฟีเจอร์ โดยพบว่าข้อมูลแต่ละฟีเจอร์ไม่ได้มีความสัมพันธ์กันมาก"""

plt.figure(figsize=[12,8])
sns.heatmap(train_df.corr(), annot=True, cmap="plasma")
plt.show()

"""# Feature Engineering
Feature Engineering คือ กระบวนการใช้ความรู้ Domain Knowledge ในการสร้าง Feature ใหม่ขึ้นมา ตัด Feature ที่ไม่เกี่ยวข้องทิ้งไป เพื่อช่วยทำให้อัลกอริทึมเรียนรู้ได้ดีขึ้น

และเนื่องจากเราไม่สามารถที่จะเลี่ยง Missing Values บาง column มีค่ามากกว่า column อื่นๆหรือ Outliner ได้ ทำให้การทำ Feature Engineering เป็นการเพิ่มประสิทธิภาพให้กับ Model

โดยเริ่มจากทำการ drop ฟีเจอร์ที่ไม่ได้ใช้งานอย่าง Name ออกจาก Data Frame เนื่องจากไม่มีผลต่อการ Transported ของผู้โดยสาร
"""

train_df.drop('Name', axis=1, inplace=True)
test_df.drop('Name', axis=1, inplace=True)

"""ต่อมาคือการ split คอลลัมน์ที่มีค่ามากกว่าคอลลัมน์อื่น โดย unique ของ 
Cabin ออกมาเป็นฟีเจอร์ใหม่ 3 ฟีเจอร์คือ deck num และ side
เมื่อทำการ split unique ของ Cabin ออกมาแล้วจึงทำการ drop ฟีเจอร์ Cabin ที่ไม่ได้ใช้งานแล้วออกไป
"""

train_df[['deck','num', 'side']] = train_df['Cabin'].str.split('/', expand=True)
test_df[['deck','num', 'side']] = test_df['Cabin'].str.split('/', expand=True)

train_df.drop('Cabin', axis=1, inplace=True)
test_df.drop('Cabin', axis=1, inplace=True)

"""กำหนดตัวแปรเพื่อนำมาแยกเก็บแต่ละฟีเจอร์ที่เป็นข้อมูลต่างชนิดกัน โดยใช้ object_cols เก็บข้อมูลที่เป็นรูปแบบ Categorical และ numeric_cols สำหรับข้อมูลรูปแบบ Numerical"""

object_cols = [col for col in train_df.columns if train_df[col].dtype == 'object' or train_df[col].dtype == 'category']
numeric_cols = [col for col in train_df.columns if train_df[col].dtype == 'float64']

print(f'Object cols -- {object_cols}')
print(f'Numeric cols -- {numeric_cols}')

"""ทำการสรุปรวมค่าใช้จ่ายของผู้โดยสาร แล้วนำมาสร้างฟีเจอร์ใหม่ SumSpends เพื่อให้ง่ายต่อการสำรวจภาพรวมของข้อมูล"""

col_to_sum = ['RoomService', 'FoodCourt', 'ShoppingMall', 'Spa', 'VRDeck']

train_df['SumSpends'] = train_df[col_to_sum].sum(axis=1)
test_df['SumSpends'] = test_df[col_to_sum].sum(axis=1)

"""ทำการสำรวจจำนวนค่า Null ในข้อมูล"""

null_cols = train_df.isnull().sum().sort_values(ascending=False)
null_cols = list(null_cols[null_cols>1].index)
null_cols

"""ใช้คำสั่ง astype() เปลี่ยนรูปแบบของข้อมูลเป็น category เป็นการแปลงประเภทข้อมูลของคอลัมน์ คอลัมน์เดียวหรือหลายคอลัมน์ไปเป็นอีกรูปแบบหนึ่งโดยใช้ฟังก์ชัน astype() ทั้งใน train, test เพื่อเปลี่ยนชนิดข้อมูลของ array ที่สร้างไว้แล้ว
วิธีที่ดีที่สุดคือการคัดลอก array นั้นออกมาโดยใช้ method ชื่อ astype()
เมื่อใช้ method นี้เราจะสามารถคัดลอก array นั้นและกำหนดชนิดข้อมูลของ array ใน parameter ได้
"""

train_df[object_cols] = train_df[object_cols].astype('category')
test_df[object_cols] = test_df[object_cols].astype('category')

print(f'Train DF shape: {train_df.shape}')
print(f'Test DF shape: {test_df.shape}')

"""# Fill Missing Value"""

for cat_col in object_cols:
    train_df[cat_col] = train_df[cat_col].fillna(train_df[cat_col].mode()[0])

for cat_col in object_cols:
    test_df[cat_col] = test_df[cat_col].fillna(test_df[cat_col].mode()[0])

train_df.info()

for num_col in numeric_cols:
    train_df[num_col] = train_df[num_col].fillna(train_df[num_col].median())
    
for num_col in numeric_cols:
    test_df[num_col] = test_df[num_col].fillna(test_df[num_col].median())

"""# Label Encoding
คือ เป็นคลาสยูทิลิตี้ที่ช่วยทำให้ป้ายกำกับเป็นมาตรฐาน โดยมีค่าระหว่าง 0 ถึง n_classes-1 เท่านั้น


การทำ Mutual Information Score เพื่อวัดความสัมพันธ์ระหว่างฟีเจอร์ และค่าที่จะทำนาย เริ่มจากแปลงคอลัมน์ที่เป็น Categorical Data ด้วยวิธีการ Label Encoding และกำหนดให้ฟีเจอร์เหล่านี้ให้เป็น Discrete Features คือ ค่าที่ไม่ต่อเนื่อง
"""

from sklearn.preprocessing import OrdinalEncoder

oc = OrdinalEncoder()

df_for_encode = pd.concat([train_df, test_df])

df_for_encode[object_cols] = df_for_encode[object_cols].astype('category')

df_for_encode[object_cols] = oc.fit_transform(df_for_encode[object_cols])

del train_df, test_df

train_df = df_for_encode.iloc[:8693, :]
test_df = df_for_encode.iloc[8693: , :]

del df_for_encode

test_df.drop('Transported', inplace=True, axis=1)

"""# Preparing

ทำการ Copy ชุดข้อมูล train เก็บไว้ในตัวแปร X และตัด Transported (ค่าที่ต้องการทำนาย) ออกเก็บไว้ในตัวแปร y
"""

X.info()

X = train_df.copy()
X.drop("Transported", axis=1)
y = X.pop('Transported')

"""# Mutal Information Score
สิ่งที่จะทำถัดไปทำคือ Mutual Information Score เพื่อวัดความสัมพันธ์ระหว่างฟีเจอร์และค่าที่จะทำนาย
วัดค่า MI Score ด้วย mutual_info_classif ของ Scikit-Learn จะได้คะแนนว่าฟีเจอร์นั้นสัมพันธ์กับค่าที่จะทำนายมากน้อยแค่ไหน

"""

y=y.astype('int')

y.head()

for colname in X.select_dtypes("object"):
    X[colname],_=[colname].factorize9()
    X[colname] = X[colname].astype(int)

discrete_features = X.dtypes == int

discrete_features

from sklearn.feature_selection import mutual_info_classif

def make_mi_scores(X, y, discrete_fetures):
    mi_scores = mutual_info_classif(X, y,discrete_features = discrete_features  )
    mi_scores = pd.Series(mi_scores, name="MI Scores Clf", index=X.columns)
    mi_scores = mi_scores.sort_values(ascending=False)

mi_scores = make_mi_scores(X, y, discrete_features)
mi_scores

"""Cat Boost"""
"""#CatBoost สร้าง Symmetric trees ไม่เหมือน XGBoost และ LightGBM ในทุกขั้นตอน ใบไม้จากต้นก่อนหน้าจะถูกแยกออกโดยใช้เงื่อนไขเดียวกัน มีการเลือกคู่คุณสมบัติ 
และใช้สำหรับโหนดของระดับทั้งหมด ช่วยในการใช้งาน CPU อย่างมีประสิทธิภาพ ลดเวลาในการคาดการณ์ ทำให้มีการใช้โมเดลที่รวดเร็ว และควบคุมการปรับให้เหมาะสมเป็นมาตรฐาน

cat_features = list(range(0, X.shape[1]))
print(cat_features)

from sklearn.model_selection import train_test_split

X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=0)

X_train.dtypes

from catboost import CatBoostClassifier
clf = CatBoostClassifier(
    iterations=5, 
    learning_rate=0.1, 
)


clf.fit(X_train, y_train, 
        eval_set=(X_val, y_val), 
        verbose=0
)

print('CatBoost model is fitted: ' + str(clf.is_fitted()))
print('CatBoost model parameters:')
print(clf.get_params())

from catboost import CatBoostClassifier
clf = CatBoostClassifier(
    iterations=10,
#     verbose=5,
)

clf.fit(
    X_train, y_train,
    eval_set=(X_val, y_val),
)

print(clf.predict(data=X_val))

"""# Submission"""


pred=clf.predict(test_df)

pred

final = pd.DataFrame()
final.index = test_df.index
final['Transported'] = pred
final.to_csv('submission4.csv')

"""# Reference"""

Subbrain.(2022).Machine Learning - Kaggle.สืบค้นเมื่อวันที่ 27 ตุลาคม 2022 จาก.https://www.sub-brain.com/datait/machine-learning/#Exploratory-Data-Analysis
Python Graph Gallery. (2018).  Density chart. สืบค้น 28 ตุลาคม 2022 จาก.https://www.python-graph-gallery.com/density-plot/
Jim Liu.(2022).isaelcribeiro solution+Modularity FE.สืบค้นเมื่อวันที่ 28 ตุลาคม 2022 จาก.https://www.kaggle.com/code/jimliu/0-81669-misaelcribeiro-solution-modularity-fe
EnkrateiaLucca.(2022).space_titanic_kaggle.สืบค้นเมื่อวันที่ 29 ตุลาคม 2022 จาก.https://github.com/EnkrateiaLucca/space_titanic_kaggle/blob/main/data_science_intro_space_titanic_kaggle.ipynb
